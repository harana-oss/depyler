// Generated by: DEPYLER stdlib validation
// Module: builtins - round() with two arguments
// Status: GREEN phase - Tests enabled

use depyler_core::DepylerPipeline;

// DEPYLER-STDLIB-BUILTINS-ROUND-TWO-ARGS-001: round(int, int)
#[test]
fn test_round_int_with_precision() {
    let python = r#"
def round_int_to_decimal(value: int, places: int) -> int:
    """Round integer to specified decimal places"""
    return round(value, places)
"#;

    let pipeline = DepylerPipeline::new();
    let result = pipeline.transpile(python).expect("Transpilation failed");

    // Should generate round with precision parameter
    assert!(result.contains("round"));
    // Should handle the second parameter
    assert!(result.contains("places"));
}

// DEPYLER-STDLIB-BUILTINS-ROUND-TWO-ARGS-002: round(float, int)
#[test]
fn test_round_float_with_precision() {
    let python = r#"
def round_float_to_decimal(value: float, places: int) -> float:
    """Round float to specified decimal places"""
    return round(value, places)
"#;

    let pipeline = DepylerPipeline::new();
    let result = pipeline.transpile(python).expect("Transpilation failed");

    // Should generate round with precision parameter
    assert!(result.contains("round"));
    // Should handle the second parameter
    assert!(result.contains("places"));
}

// DEPYLER-STDLIB-BUILTINS-ROUND-TWO-ARGS-003: round with negative precision
#[test]
fn test_round_with_negative_precision() {
    let python = r#"
def round_with_negative_precision(x: float, precision: int) -> float:
    """Test round() with negative precision"""
    return round(x, precision)
"#;

    let pipeline = DepylerPipeline::new();
    let result = pipeline.transpile(python).expect("Transpilation failed");

    // Should generate round with precision parameter
    assert!(result.contains("round"));
    // Should handle negative precision (rounds to left of decimal)
    assert!(result.contains("precision"));
}

// DEPYLER-STDLIB-BUILTINS-ROUND-TWO-ARGS-004: Multiple round operations
#[test]
fn test_round_multiple_operations() {
    let python = r#"
def test_round_int_with_precision():
    """Test round() with int first argument and int second argument"""
    result1 = round(123, 0)
    result2 = round(123, -1)
    result3 = round(125, -1)
    result4 = round(127, -1)
    return result1, result2, result3, result4
"#;

    let pipeline = DepylerPipeline::new();
    let result = pipeline.transpile(python).expect("Transpilation failed");

    // Should generate multiple round calls
    assert!(result.contains("round"));
    // Should handle literal integers
    assert!(result.contains("123") || result.contains("125") || result.contains("127"));
}

// DEPYLER-STDLIB-BUILTINS-ROUND-TWO-ARGS-005: Round float with various precisions
#[test]
fn test_round_float_various_precisions() {
    let python = r#"
def test_round_float_with_precision():
    """Test round() with float first argument and int second argument"""
    result1 = round(3.14159, 2)
    result2 = round(2.675, 2)
    result3 = round(1.5, 0)
    result4 = round(2.5, 0)
    result5 = round(12.345, 1)
    return result1, result2, result3, result4, result5
"#;

    let pipeline = DepylerPipeline::new();
    let result = pipeline.transpile(python).expect("Transpilation failed");

    // Should generate multiple round calls
    assert!(result.contains("round"));
    // Should handle floating point literals
    assert!(result.contains("3.14159") || result.contains("2.675") || result.contains("12.345"));
}

// DEPYLER-STDLIB-BUILTINS-ROUND-TWO-ARGS-006: Round with variable as first argument
#[test]
fn test_round_variable_with_precision() {
    let python = r#"
def round_variable_with_precision():
    """Test round() with variable as first argument"""
    x = 3.14159
    result1 = round(x, 2)
    
    y = 123.456
    result2 = round(y, 1)
    
    z = 999.999
    result3 = round(z, 0)
    
    return result1, result2, result3
"#;

    let pipeline = DepylerPipeline::new();
    let result = pipeline.transpile(python).expect("Transpilation failed");

    // Should generate round calls with variables
    assert!(result.contains("round"));
    // Should handle variable names
    assert!(result.contains("x") || result.contains("y") || result.contains("z"));
    // Should contain the precision values
    assert!(result.contains("2") || result.contains("1") || result.contains("0"));
}

// DEPYLER-STDLIB-BUILTINS-ROUND-TWO-ARGS-007: Round with integer variable as first argument
#[test]
fn test_round_variable_int_with_precision() {
    let python = r#"
def round_variable_int_with_precision():
    """Test round() with integer variable as first argument"""
    value = 127
    result1 = round(value, -1)
    
    large_num = 12345
    result2 = round(large_num, -2)
    
    return result1, result2
"#;

    let pipeline = DepylerPipeline::new();
    let result = pipeline.transpile(python).expect("Transpilation failed");

    // Should generate round calls with variables
    assert!(result.contains("round"));
    // Should handle variable names
    assert!(result.contains("value") || result.contains("large_num"));
    // Should handle negative precision (check for digit patterns or negative signs)
    assert!(result.contains("1") || result.contains("2"));
}

// DEPYLER-STDLIB-BUILTINS-ROUND-TWO-ARGS-008: Round with computed value as first argument
#[test]
fn test_round_computed_value() {
    let python = r#"
def round_computed_value():
    """Test round() with computed value as first argument"""
    a = 10.5
    b = 3.2
    result1 = round(a + b, 1)
    
    c = 100.0
    d = 3.0
    result2 = round(c / d, 2)
    
    return result1, result2
"#;

    let pipeline = DepylerPipeline::new();
    let result = pipeline.transpile(python).expect("Transpilation failed");

    // Should generate round calls with computed expressions
    assert!(result.contains("round"));
    // Should handle arithmetic operations
    assert!(result.contains("+") || result.contains("/"));
    // Should contain variable names
    assert!(
        result.contains("a")
            || result.contains("b")
            || result.contains("c")
            || result.contains("d")
    );
}

// Total: 8 tests for round() with two arguments
// Coverage: round(int, int), round(float, int), negative precision, multiple operations, variables, computed values
